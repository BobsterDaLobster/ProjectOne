<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Personal Profile â€” with Crossy Mini-game</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;background:linear-gradient(90deg,#add8e6,#ffd580);color:#222}
    header{background:#87cefa;color:#fff;text-align:center;padding:1rem}
    section{padding:1rem}
    .calendar-container{display:flex}
    .calendar{flex:2;display:grid;grid-template-columns:repeat(7,1fr);gap:5px}
    .calendar div{padding:10px;background:#fff;text-align:center;border-radius:4px;cursor:pointer}
    .calendar .today{background:#ffd580;font-weight:700}
    .event-panel{flex:1;margin-left:20px;background:#fff;padding:10px;border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,.12)}
    canvas{display:block;margin:0 auto;border:2px solid #333;background:#eee}
    .news-section{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px}
    .news-article{background:#fff;padding:10px;border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,.08)}
    .secret-button{position:fixed;bottom:5px;right:5px;width:16px;height:16px;background:transparent;border:none;cursor:pointer}
    /* small responsive: shrink canvas on narrow screens */
    @media (max-width:420px){ canvas{width:320px;height:440px} }
  </style>
</head>
<body>
  <header><h1>My Personal Profile</h1></header>

  <section>
    <h2>My Resume</h2>
    <p>Paste or write your resume here (editable area not implemented in this file).</p>
  </section>

  <section>
    <h2>Calendar</h2>
    <div class="calendar-controls">
      <button onclick="prevMonth()">Previous</button>
      <span id="monthYear"></span>
      <button onclick="nextMonth()">Next</button>
    </div>
    <div class="calendar-container">
      <div class="calendar" id="calendar"></div>
      <div class="event-panel">
        <h3 id="selectedDate"></h3>
        <ul id="eventList"></ul>
        <input id="newEvent" placeholder="New Event" />
        <button onclick="addEvent()">Add</button>
      </div>
    </div>
  </section>

  <section>
    <h2>Sports News (via ESPN)</h2>
    <p><a href="https://www.espn.com" target="_blank">Go to ESPN for latest sports news & highlights</a></p>
  </section>

  <section>
    <h2>Notre Dame Fighting Irish Football</h2>
    <p><a href="https://www.espn.com/college-football/team/_/id/87/notre-dame-fighting-irish" target="_blank">Notre Dame Football on ESPN</a></p>
  </section>

  <section>
    <h2>World News</h2>
    <div id="news" class="news-section"></div>
  </section>

  <section>
    <h2>Mini-Game: Crossy Road Clone</h2>
    <!-- base size 400x550 (canvas scaled for DPR in script) -->
    <canvas id="gameCanvas" width="400" height="550" style="max-width:100%;height:auto"></canvas>
    <p style="text-align:center;font-size:0.9rem;margin-top:6px">Use the on-screen keypad (bottom-right) or arrow keys.</p>
  </section>

  <button class="secret-button" onclick="redirectSecret()"></button>

<script>
/* ----------------- Calendar (unchanged) ----------------- */
const calendarEl = document.getElementById('calendar');
const monthYearEl = document.getElementById('monthYear');
const selectedDateEl = document.getElementById('selectedDate');
const eventListEl = document.getElementById('eventList');
const newEventEl = document.getElementById('newEvent');

let currentDate = new Date();
let events = JSON.parse(localStorage.getItem('events') || '{}');

function renderCalendar() {
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  const firstDay = new Date(year, month, 1).getDay();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  calendarEl.innerHTML = '';
  monthYearEl.textContent = `${currentDate.toLocaleString('default',{month:'long'})} ${year}`;
  for (let i = 0; i < firstDay; i++) calendarEl.appendChild(document.createElement('div'));
  for (let d = 1; d <= daysInMonth; d++) {
    const cell = document.createElement('div');
    cell.textContent = d;
    const today = new Date();
    if (d === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
      cell.classList.add('today');
      loadEvents(new Date(year, month, d));
    }
    cell.onclick = () => loadEvents(new Date(year, month, d));
    calendarEl.appendChild(cell);
  }
}
function loadEvents(date) {
  const key = date.toDateString();
  selectedDateEl.textContent = key;
  eventListEl.innerHTML = '';
  (events[key] || []).forEach((ev,i)=> {
    const li = document.createElement('li');
    li.textContent = ev;
    const b = document.createElement('button'); b.textContent='X';
    b.onclick = ()=>{ events[key].splice(i,1); localStorage.setItem('events',JSON.stringify(events)); loadEvents(date);};
    li.appendChild(b);
    eventListEl.appendChild(li);
  });
  selectedDateEl.dataset.date = key;
}
function addEvent(){ const key = selectedDateEl.dataset.date; if(!key) return; if(!events[key]) events[key]=[]; events[key].push(newEventEl.value||'(no title)'); newEventEl.value=''; localStorage.setItem('events',JSON.stringify(events)); loadEvents(new Date(key));}
function deleteEvent(key,i){ events[key].splice(i,1); localStorage.setItem('events',JSON.stringify(events)); loadEvents(new Date(key));}
function prevMonth(){ currentDate.setMonth(currentDate.getMonth()-1); renderCalendar();}
function nextMonth(){ currentDate.setMonth(currentDate.getMonth()+1); renderCalendar();}
renderCalendar();

/* ----------------- News (RSS -> JSON public proxy) ----------------- */
async function fetchNews(){
  try{
    // rss2json public endpoint (no key required for basic use)
    const res = await fetch("https://api.rss2json.com/v1/api.json?rss_url=https://news.google.com/rss?hl=en-US&gl=US&ceid=US:en");
    const data = await res.json();
    const container = document.getElementById('news');
    container.innerHTML = '';
    (data.items || []).slice(0,6).forEach(it => {
      const d = document.createElement('div'); d.className='news-article';
      d.innerHTML = `
        <h4><a href="${it.link}" target="_blank" rel="noopener">${it.title}</a></h4>
        ${it.thumbnail? `<img src="${it.thumbnail}" alt="" style="max-width:100%;margin-bottom:6px">` : ''}
        <p>${(it.description||'').replace(/<\/?[^>]+(>|$)/g,"").slice(0,200)}${(it.description||'').length>200?'...':''}</p>
      `;
      container.appendChild(d);
    });
  }catch(e){
    console.error('News fetch failed',e);
    document.getElementById('news').innerHTML = '<p style="color:#a00">News unavailable right now â€” try again later.</p>';
  }
}
fetchNews();
setInterval(fetchNews, 30*60*1000); // 30 minutes

/* ----------------- Secret Redirect (unchanged) ----------------- */
function redirectSecret(){
  const code = prompt('Enter secret code:');
  if(code === '494849') window.location.href = 'https://poki.com';
}

/* ----------------- Crossy Road Mini-game (fixed) ----------------- */
/*
 - TILE: lane height and player size (20px)
 - canvas is DPI-scaled properly
 - single RAF loop with timestamp delta
 - lanes have fixed per-lane spawn timers and baseSpeed so reset doesn't speed up existing lanes
 - player always snaps to TILE grid and spawns centered horizontally in bottom safe zone
 - click/touch keypad scaled correctly to canvas coordinate system
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- DPI scaling so canvas coordinates map 1:1 to drawing buffer
function resizeCanvasForDPR() {
  const dpr = window.devicePixelRatio || 1;
  // keep logical size as given by width/height attributes : 400x550 (unless responsive CSS changed)
  const rect = canvas.getBoundingClientRect();
  // set backing store based on displayed CSS size
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing ops so we can use CSS px coordinates
}
window.addEventListener('resize', resizeCanvasForDPR);
resizeCanvasForDPR();

/* Game constants */
const TILE = 20;                 // height of each lane
const PLAYER_SIZE = TILE;        // make the player exactly one tile
const START_LANES = 30;         // initially generate this many lanes
const SAFE_ZONE_LANES = 5;      // initial safe zone at bottom
const CANVAS_W = Math.round(canvas.getBoundingClientRect().width);
const CANVAS_H = Math.round(canvas.getBoundingClientRect().height);

let player = null;
let lanes = []; // each lane: { type:'grass'|'road'|'river', cars:[], logs:[], spawnTimer, baseSpeed }
let offsetY = 0;
let score = 0;

/* Use consistent random seeds per lane generation (not across resets) by using Math.random but setting per-lane baseSpeed */
function generateLane(index){
  // create lane object with stable properties at creation time
  if(index % 10 === 0) return { type:'grass' };

  const r = Math.floor(Math.random()*15)+1;
  if(r <= 7){
    // road lane: fixed base speed and spawn interval at creation
    return {
      type:'road',
      cars:[],
      spawnTimer: Math.random()*2000 + 800, // ms
      spawnAcc: 0,
      baseSpeed: (Math.random()*0.6 + 0.6) * (Math.random()<0.5 ? -1 : 1) // Â±0.6..1.2 px per frame equivalent (we will scale by dt)
    };
  } else if(r <= 10){
    return {
      type:'river',
      logs:[],
      spawnTimer: Math.random()*2200 + 1200,
      spawnAcc: 0,
      baseSpeed: (Math.random()*0.5 + 0.4) * (Math.random()<0.5 ? -1 : 1)
    };
  } else {
    return { type:'grass' };
  }
}

function generateInitialLanes(){
  lanes = [];
  for(let i=0;i<SAFE_ZONE_LANES;i++) lanes.push({type:'grass'});
  for(let i=SAFE_ZONE_LANES;i<START_LANES;i++) lanes.push(generateLane(i));
}

function initPlayer(){
  // horizontally centered (in tiles) and vertically on the bottom safe zone
  const centerX = Math.floor((CANVAS_W/2) / TILE) * TILE;
  const startY = (CANVAS_H - TILE*2); // bottom-ish; ensure it's on a tile
  player = { x:centerX, y:startY, size:PLAYER_SIZE };
  // snap to grid
  player.x = Math.max(0, Math.min(player.x, CANVAS_W - PLAYER_SIZE));
  player.y = Math.max(0, Math.min(player.y, CANVAS_H - PLAYER_SIZE));
  player.x = Math.floor(player.x / TILE) * TILE;
  player.y = Math.floor(player.y / TILE) * TILE;
}

/* Reset but do NOT start multiple loops */
function resetGame(){
  offsetY = 0;
  score = 0;
  generateInitialLanes();
  initPlayer();
  // clear any moving objects (they are on lanes)
}

/* Movement */
function move(dir){
  if(!player) return;
  if(dir==='up') player.y -= TILE;
  if(dir==='down') player.y += TILE;
  if(dir==='left') player.x -= TILE;
  if(dir==='right') player.x += TILE;
  // clamp
  player.x = Math.max(0, Math.min(player.x, CANVAS_W - PLAYER_SIZE));
  player.y = Math.max(0, Math.min(player.y, CANVAS_H - PLAYER_SIZE));
  // snap
  player.x = Math.floor(player.x / TILE) * TILE;
  player.y = Math.floor(player.y / TILE) * TILE;

  // when moving up off top area, scroll world (offsetY increased)
  if(player.y < TILE*6){ // once player near top area, scroll world
    offsetY += TILE;
    player.y += TILE; // keep player visually in same canvas area
    score++;
    // generate more lanes if needed
    while(lanes.length < Math.floor(score/TILE) + 40) lanes.push(generateLane(lanes.length));
  }
}

/* Helper: spawn cars/logs using per-lane spawnTimer & spawnAcc (ms accumulation) */
function updateSpawns(dt){
  for(let i=0;i<lanes.length;i++){
    const lane = lanes[i];
    if(lane.type === 'road' || lane.type === 'river'){
      lane.spawnAcc += dt;
      if(lane.spawnAcc >= lane.spawnTimer){
        lane.spawnAcc = 0;
        if(lane.type === 'road'){
          const startX = Math.random()<0.5 ? -60 : CANVAS_W+20;
          const speed = lane.baseSpeed * (50/16); // scale so speed is reasonable with dt
          lane.cars.push({ x: startX, speed: speed });
        } else {
          const startX = Math.random()<0.5 ? -100 : CANVAS_W+20;
          const speed = lane.baseSpeed * (50/16);
          lane.logs.push({ x: startX, speed: speed });
        }
      }
      // optionally trim arrays to avoid huge growth
      if(lane.cars && lane.cars.length > 20) lane.cars.splice(0, lane.cars.length - 20);
      if(lane.logs && lane.logs.length > 20) lane.logs.splice(0, lane.logs.length - 20);
    }
  }
}

/* Main loop using RAF with timestamp to compute dt (ms) */
let lastTs = null;
function gameLoop(ts){
  if(!lastTs) lastTs = ts;
  const dt = Math.min(50, ts - lastTs); // clamp dt to avoid big jumps
  lastTs = ts;

  // update spawns using dt
  updateSpawns(dt);

  // move vehicles/logs by speed * (dt/16) to make motion framerate independent-ish
  for(let i=0;i<lanes.length;i++){
    const lane = lanes[i];
    const laneY = CANVAS_H - (i * TILE) + offsetY;
    if(lane.type === 'road' && lane.cars){
      for(let j=0;j<lane.cars.length;j++){
        lane.cars[j].x += lane.cars[j].speed * (dt/16);
      }
    } else if(lane.type === 'river' && lane.logs){
      for(let j=0;j<lane.logs.length;j++){
        lane.logs[j].x += lane.logs[j].speed * (dt/16);
      }
    }
  }

  // collision detection & drawing
  // clear
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

  // draw lanes and moving objects
  for(let i=0;i<lanes.length;i++){
    const lane = lanes[i];
    const laneY = CANVAS_H - ((i+1) * TILE) + offsetY; // compute Y relative to bottom
    if(laneY < -TILE || laneY > CANVAS_H + TILE) continue;

    if(lane.type === 'grass'){
      ctx.fillStyle = '#7cfc00';
      ctx.fillRect(0,laneY,CANVAS_W,TILE);
    } else if(lane.type === 'road'){
      ctx.fillStyle = '#444';
      ctx.fillRect(0,laneY,CANVAS_W,TILE);
      // update and draw cars
      lane.cars.forEach(car => {
        ctx.fillStyle = '#c0392b';
        ctx.fillRect(car.x, laneY, 40, TILE);
      });
      // collision check
      lane.cars.forEach(car => {
        if(player.x < car.x + 40 && player.x + PLAYER_SIZE > car.x && player.y < laneY + TILE && player.y + PLAYER_SIZE > laneY){
          // hit -> reset everything (no global speed increase)
          resetGame();
        }
      });
    } else if(lane.type === 'river'){
      ctx.fillStyle = '#00a4ff';
      ctx.fillRect(0,laneY,CANVAS_W,TILE);
      lane.logs.forEach(log => {
        ctx.fillStyle = 'saddlebrown';
        ctx.fillRect(log.x, laneY, 80, TILE);
      });
      let onLog = false;
      lane.logs.forEach(log => {
        if(player.x < log.x + 80 && player.x + PLAYER_SIZE > log.x && player.y < laneY + TILE && player.y + PLAYER_SIZE > laneY){
          onLog = true;
          // ride with the log
          player.x += log.speed * (dt/16);
        }
      });
      if(player.y < laneY + TILE && player.y + PLAYER_SIZE > laneY && !onLog){
        resetGame();
      }
    }
  }

  // draw player (snapped to grid for visuals)
  player.x = Math.floor(player.x / TILE) * TILE;
  player.y = Math.floor(player.y / TILE) * TILE;
  ctx.fillStyle = 'yellow';
  ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
  ctx.fillStyle = '#111';
  ctx.fillText('Score: '+score, 8, 18);

  // draw keypad (bottom-right)
  const baseX = CANVAS_W - 170;
  const baseY = CANVAS_H - 120;
  const keyDefs = [
    {label:'â¬†ï¸', x:baseX+50, y:baseY, w:40, h:30},
    {label:'â¬…ï¸', x:baseX, y:baseY+40, w:40, h:30},
    {label:'â¬‡ï¸', x:baseX+50, y:baseY+40, w:40, h:30},
    {label:'âž¡ï¸', x:baseX+100, y:baseY+40, w:40, h:30},
    {label:'ðŸ”„', x:baseX+50, y:baseY+80, w:40, h:30}
  ];
  ctx.font = '16px sans-serif';
  keyDefs.forEach(k => {
    ctx.fillStyle = '#87cefa';
    ctx.fillRect(k.x, k.y, k.w, k.h);
    ctx.fillStyle = 'white';
    ctx.fillText(k.label, k.x + 10, k.y + k.h/2 + 2);
  });

  requestAnimationFrame(gameLoop);
}

/* Input handling: map clicks/touches to canvas-scaled coordinates */
function getCanvasCoords(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  // We scaled canvas backing for DPR but we used ctx.setTransform to keep drawing coordinate same as CSS px.
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  return {x, y};
}

canvas.addEventListener('click', function(e){
  const p = getCanvasCoords(e.clientX, e.clientY);
  handleKeypadClick(p.x, p.y);
});
canvas.addEventListener('touchstart', function(e){
  if(!e.touches || e.touches.length===0) return;
  const t = e.touches[0];
  const p = getCanvasCoords(t.clientX, t.clientY);
  handleKeypadClick(p.x, p.y);
  e.preventDefault();
},{passive:false});

function handleKeypadClick(x,y){
  const baseX = CANVAS_W - 170;
  const baseY = CANVAS_H - 120;
  const regions = {
    up:    {x: baseX+50, y: baseY, w:40, h:30, label:'â¬†ï¸'},
    left:  {x: baseX, y: baseY+40, w:40, h:30, label:'â¬…ï¸'},
    down:  {x: baseX+50, y: baseY+40, w:40, h:30, label:'â¬‡ï¸'},
    right: {x: baseX+100, y: baseY+40, w:40, h:30, label:'âž¡ï¸'},
    restart:{x: baseX+50, y: baseY+80, w:40, h:30, label:'ðŸ”„'}
  };
  for(const [k,r] of Object.entries(regions)){
    if(x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h){
      // flash visual (draw immediate)
      ctx.fillStyle = '#ffd580'; ctx.fillRect(r.x,r.y,r.w,r.h);
      ctx.fillStyle = 'white'; ctx.fillText(r.label, r.x + 10, r.y + r.h/2 + 2);
      setTimeout(()=>{ /* redraw will occur on next frame by gameLoop */ },120);

      if(k === 'restart') resetGame();
      else move(k);
      return;
    }
  }
}

/* keyboard support */
window.addEventListener('keydown', e=>{
  if(e.key === 'ArrowUp') move('up');
  if(e.key === 'ArrowDown') move('down');
  if(e.key === 'ArrowLeft') move('left');
  if(e.key === 'ArrowRight') move('right');
});

/* Start everything */
resetGame();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
