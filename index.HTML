<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Personal Profile Website</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(to right, #add8e6, #ffd580);
      margin: 0;
      padding: 0;
      color: #333;
    }
    header {
      text-align: center;
      padding: 1rem;
      background: #87cefa;
      color: white;
    }
    section { padding: 1rem; }
    canvas {
      background: #eee;
      display: block;
      margin: 0 auto;
      border: 2px solid #333;
    }
    .news-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
    }
    .news-article {
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    .news-article img {
      max-width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    .secret-button {
      position: fixed;
      bottom: 5px;
      right: 5px;
      width: 15px;
      height: 15px;
      background: transparent;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <h1>My Personal Profile</h1>
  </header>

  <section>
    <h2>World News</h2>
    <div id="news" class="news-section"></div>
  </section>

  <section>
    <h2>Mini-Game: Crossy Road Clone</h2>
    <canvas id="gameCanvas" width="400" height="550"></canvas>
  </section>

  <button class="secret-button" onclick="redirectSecret()"></button>

  <script>
    // ===== World News via RSS =====
    async function fetchNews() {
      try {
        const res = await fetch("https://api.rss2json.com/v1/api.json?rss_url=https://rss.nytimes.com/services/xml/rss/nyt/World.xml");
        const data = await res.json();
        const container = document.getElementById("news");
        container.innerHTML = "";
        data.items.slice(0,6).forEach(article => {
          const div = document.createElement("div");
          div.className = "news-article";
          div.innerHTML = `
            <img src="${article.enclosure?.link || 'https://via.placeholder.com/150'}" alt="thumbnail">
            <h4><a href="${article.link}" target="_blank">${article.title}</a></h4>
            <p>${article.description.substring(0,100)}...</p>
          `;
          container.appendChild(div);
        });
      } catch (e) {
        console.error("News fetch error", e);
      }
    }
    fetchNews();
    setInterval(fetchNews, 1800000);

    // ===== Secret Redirect =====
    function redirectSecret() {
      const code = prompt("Enter secret code:");
      if (code === "494849") {
        window.location.href = "https://poki.com";
      }
    }

    // ===== Game Logic =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let player, lanes, offsetY, score, highScore, gameOver, gameRunning;

    highScore = parseInt(localStorage.getItem("crossyHighScore")) || 0;

    function resetGame() {
      player = { x: 200, y: 520, size: 20 };
      lanes = [];
      offsetY = 0;
      score = 0;
      gameOver = false;
      gameRunning = true;
      generateInitialLanes();
      requestAnimationFrame(gameLoop);
    }

    function generateInitialLanes() {
      for (let i = 0; i < 30; i++) {
        generateLane(i);
      }
    }

    function generateLane(index) {
      if (index % 10 === 0) {
        lanes.push({ type: 'grass' });
      } else {
        const rand = Math.floor(Math.random() * 15) + 1;
        if (rand <= 7) lanes.push({ type: 'road', cars: [] });
        else if (rand <= 10) lanes.push({ type: 'river', logs: [] });
        else lanes.push({ type: 'grass' });
      }
    }

    function move(dir) {
      if (!gameRunning) return;
      if (dir === 'up') player.y -= 20;
      if (dir === 'down') player.y += 20;
      if (dir === 'left') player.x -= 20;
      if (dir === 'right') player.x += 20;

      if (player.y < 200) {
        offsetY += 20;
        player.y += 20;
        score++;
        if (lanes.length < score/20 + 40) generateLane(lanes.length);
      }
    }

    function triggerGameOver() {
      gameOver = true;
      gameRunning = false;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("crossyHighScore", highScore);
      }
      drawGameOver();
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      ctx.font = "24px Arial";
      ctx.fillText("Game Over!", 140, 250);
      ctx.fillText("Score: " + score, 150, 290);
      ctx.fillText("High Score: " + highScore, 120, 330);
      ctx.fillText("Click Restart ⟳ to play again", 60, 370);
    }

    function gameLoop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if (!gameOver) {
        for (let i = 0; i < lanes.length; i++) {
          const laneY = 550 - (i*20) + offsetY;
          if (laneY < -20 || laneY > 570) continue;

          if (lanes[i].type === 'grass') {
            ctx.fillStyle = '#7cfc00';
            ctx.fillRect(0, laneY, 400, 20);
          } else if (lanes[i].type === 'road') {
            ctx.fillStyle = '#444';
            ctx.fillRect(0, laneY, 400, 20);
            if (Math.random() < 0.01) {
              lanes[i].cars.push({ x: Math.random()<0.5?-40:440, speed: (Math.random()*1+0.5)*(Math.random()<0.5?-1:1) });
            }
            lanes[i].cars.forEach(car => {
              ctx.fillStyle = 'red';
              car.x += car.speed;
              ctx.fillRect(car.x, laneY, 40, 20);
              if (player.x < car.x+40 && player.x+20>car.x && player.y < laneY+20 && player.y+20>laneY) triggerGameOver();
            });
          } else if (lanes[i].type === 'river') {
            ctx.fillStyle = '#00f';
            ctx.fillRect(0, laneY, 400, 20);
            if (Math.random() < 0.06) { // logs more frequent
              lanes[i].logs.push({ x: Math.random()<0.5?-80:440, speed: (Math.random()*0.7+0.3)*(Math.random()<0.5?-1:1) });
            }
            let onLog = false;
            lanes[i].logs.forEach(log => {
              ctx.fillStyle = 'saddlebrown';
              log.x += log.speed;
              ctx.fillRect(log.x, laneY, 80, 20);
              if (player.x < log.x+80 && player.x+20>log.x && player.y < laneY+20 && player.y+20>laneY) {
                onLog = true;
                player.x += log.speed;
              }
            });
            if (player.y < laneY+20 && player.y+20 > laneY && !onLog) triggerGameOver();
          }
        }

        ctx.fillStyle = 'yellow';
        ctx.fillRect(player.x, player.y, player.size, player.size);

        ctx.fillStyle = 'black';
        ctx.fillText('Score: '+score, 10, 20);
        ctx.fillText('High: '+highScore, 320, 20);

        // Draw keypad
        const baseX = canvas.width - 170;
        const baseY = canvas.height - 120;
        const keys = [
          {label:'⬆️', x: baseX+50, y: baseY, w:40, h:30, action:'up'},
          {label:'⬅️', x: baseX, y: baseY+40, w:40, h:30, action:'left'},
          {label:'⬇️', x: baseX+50, y: baseY+40, w:40, h:30, action:'down'},
          {label:'➡️', x: baseX+100, y: baseY+40, w:40, h:30, action:'right'},
          {label:'⟳', x: baseX+50, y: baseY+80, w:40, h:30, action:'restart'}
        ];
        keys.forEach(k => {
          ctx.fillStyle = '#87cefa';
          ctx.fillRect(k.x, k.y, k.w, k.h);
          ctx.fillStyle = 'white';
          ctx.fillText(k.label, k.x+10, k.y+20);
        });
      } else {
        drawGameOver();
      }

      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('click', function(evt){
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      const baseX = canvas.width - 170;
      const baseY = canvas.height - 120;

      const regions = {
        up:    {x: baseX+50, y: baseY, w:40, h:30},
        left:  {x: baseX, y: baseY+40, w:40, h:30},
        down:  {x: baseX+50, y: baseY+40, w:40, h:30},
        right: {x: baseX+100, y: baseY+40, w:40, h:30},
        restart:{x: baseX+50, y: baseY+80, w:40, h:30}
      };

      for (const [key, r] of Object.entries(regions)) {
        if (x > r.x && x < r.x + r.w && y > r.y && y < r.y + r.h) {
          if (key === "restart") {
            resetGame();
          } else {
            move(key);
          }
        }
      }
    });

    resetGame();
  </script>
</body>
</html>
